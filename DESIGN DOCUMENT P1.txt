			+--------------------+
			| CS 140             |
			| PROJECT 1: THREADS |
			| DESIGN DOCUMENT    |
			+--------------------+
				   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

			     ALARM CLOCK
			     ===========

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

添加到结构体thread（struct thread）
	/*被原有函数timer_sleep(),thread_create()和新建函数blocked_time_check所引用*/
	int64_t blocked_time /*用于记录所设置的阻塞时间*/

---- ALGORITHMS ----

>> A2: Briefly describe what happens in a call to timer_sleep(),
>> including the effects of the timer interrupt handler.

>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

---- SYNCHRONIZATION ----

>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

---- RATIONALE ----

>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

			 PRIORITY SCHEDULING
			 ===================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

>> B2: Explain the data structure used to track priority donation.
>> Use ASCII art to diagram a nested donation.  (Alternately, submit a
>> .png file.)

---- ALGORITHMS ----

>> B3: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?

>> B4: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?

>> B5: Describe the sequence of events when lock_release() is called
>> on a lock that a higher-priority thread is waiting for.

---- SYNCHRONIZATION ----

>> B6: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?

---- RATIONALE ----

>> B7: Why did you choose this design?  In what ways is it superior to
>> another design you considered?

			  ADVANCED SCHEDULER
			  ==================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

typedef int fixed_t;               /* 用于浮点计算 */

struct thread 结构体中加入以下成员变量
	int nice;                      /* 题目中要求的nice */
	fixed_t recent_cpu;            /* 题目中要求的rcecent_cpu */

thread.c中加入全局变量
	fixed_t load_avg;              /* 题目中要求的load_avg */

---- ALGORITHMS ----

>> C2: Suppose threads A, B, and C have nice values 0, 1, and 2.  Each
>> has a recent_cpu value of 0.  Fill in the table below showing the
>> scheduling decision and the priority and recent_cpu values for each
>> thread after each given number of timer ticks:

timer  recent_cpu    priority   thread
ticks   A   B   C   A   B   C   to run
-----  --  --  --  --  --  --   ------
 0		0	0	0	63	61	59	A
 4		4	0	0	62	61	59	A
 8		8	0	0	61	61	59	B
12		8	4	0	61	60	59	A
16		12	4	0	60	60	59	B
20		12	8	0	60	59	59	A
24		16	8	0	59	59	59	C
28		16	8	4	59	59	58	B
32		16	12	4	59	58	58	A
36		20	12	4	58	58	58	C

>> C3: Did any ambiguities in the scheduler specification make values
>> in the table uncertain?  If so, what rule did you use to resolve
>> them?  Does this match the behavior of your scheduler?

在多个线程的优先级相同的时候，选择优先级最大的线程是不确定的。为了解决该问题，
我们修改了线程优先级的比较函数，以优先级为第一关键字，线程的recent_cpu为第二
关键字，线程的nice为第三关键字，如果两个线程的优先级、recent_cpu、nice都相同
那么就随机选取一个线程。

>> C4: How is the way you divided the cost of scheduling between code
>> inside and outside interrupt context likely to affect performance?

如果CPU花太多时间进用来计算recent_cpu，load_avg和priority的计算，那么在执
行抢占之前，线程将花费大量时间。这样，该线程将无法获得预期的足够的运行时间，
并且将运行更长的时间。这将导致自己占用更多的CPU时间，并会提高load_avg，导致
降低优先级。因此，如果在中断上下文中进行调度的成本增加，则会降低性能。所以我
们在每4个tick之后才进行一次计算，更新recent_cpu和nice等相关值。


---- RATIONALE ----

>> C5: Briefly critique your design, pointing out advantages and
>> disadvantages in your design choices.  If you were to have extra
>> time to work on this part of the project, how might you choose to
>> refine or improve your design?

优点：
1、在原有系统的基础上只做了少量的修改，新添加的数据结构和变量较少，尽可能优化
原有系统。
2、浮点运算利用了系统原有的int类型，利用位运算等操作提升计算速度。

缺点：
1、在本次实验中，我们只选用了一个队列来存储所有等待调用的线程，而线程的优先级只
有64个，那么就会包含很多相同优先级的线程，在多级反馈队列调度算法中，应当使用
多个队列来存储等待调度的线程，每个队列内含有若干个相同优先级的线程。
2、浮点运算方面采用了函数来计算，如果用define来定义会提升更多的性能。

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
